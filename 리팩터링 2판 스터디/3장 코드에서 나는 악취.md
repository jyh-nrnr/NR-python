# 리팩터링 2판
## 3장 코드에서 나는 악취

### 3.1 기이한 이름
### 3.2 중복 코드
### 3.3 긴 함수
- 함수를 리팩터링할 때 매개변수와 임시변수가 너무 많으면 방해됨
- *임시변수를 질의함수로 바꾸기*로 임시변수의 수를, *매개변수 객체 만들기와 객체 통채로 넘기기*로 매개변수의 수를 줄일 수 있음
- 이 보다 더 큰 수술로 *함수를 명령으로 바꾸기*도 있음
- 조건문도 리팩터링 가능. *조건문 분해*하기나 switch문이 여러개인 경우 *조건문을 다형성으로 바꾸기* 적용 가능
- 반복문도 *반복문 쪼개기*를 통해 작업의 분리 생각해보기
### 3.4 긴 매개변수 목록
- 다른 매개변수에서 값을 얻어올 수 있는 매개변수 -> *매개변수를 질의함수로 바꾸기*를 사용해 제거
- 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개볏누로 전달하는 코드라면 *객체 통채로 넘기기* 사용 가능
- 항상 함께 전달되는 매개변수들은 *매개변수 객체 만들기*로 묶어버림
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 *플래그 인수 제거하기*로 없앰
- 매개변수를 없애기에 클래스를 사용하는 것도 방법인데, 여러 함수가 특정 매개변수들의 값을 공통으로 사용할 때 특히 유용함. *여러 함수를 클래스로 묶기*를 이용해 공통 값들을 클래스의 필드로 정의함
### 3.5 전역 데이터
- 디버깅 하기가 굉장히 어려움
- 이를 방지하기 위해 *변수 캡슐화*하기 방법을 사용함
### 3.6 뒤엉킨 변경
### 3.7 산탄총 수술
### 3.8 기능 편애
### 3.9 데이터 뭉치
### 3.10 기본형 집착
### 3.11 기본형 집착
### 3.12 반복되는 switch문반복문
### 3.13 반복문
### 3.14 성의 없는 요소
### 3.15 추측성 일반화
### 3.16 임시 필드
### 3.17 메시지 체인
### 3.18 중개자
### 3.19 내부자 거래
### 3.20 거대한 클래스
### 3.21 서로 다른 인터페이스의 대안 클래스들
### 3.22 데이터 클래스
### 3.23 상속 포기
### 3.24 주석
